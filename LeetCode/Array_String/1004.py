#!/usr/bin/env python
# coding:utf-8

"""
1004. 最大连续1的个数 III
难度
中等

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。



示例 1：

输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：

输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。


提示：

1 <= A.length <= 20000
0 <= K <= A.length
A[i] 为 0 或 1
"""
# ================================================================================
"""
思路:
    队列
时间复杂度:
    O(n)
空间复杂度: 
    O(n)
"""


class Solution(object):
    def longestOnes(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        from collections import deque
        queue = deque()
        zero_count = 0
        max_count = 0
        for n in A:
            if n == 1 or zero_count < K:
                queue.append(n)
                if n == 0:
                    zero_count += 1
                    pass
            else:
                # 遇到了超出队列容忍界限的 0
                # 加入新的 0
                queue.append(n)
                # 把第一个 0 之前的元素全部出队
                while True:
                    if queue.popleft() == 0:
                        break
                    pass
                pass
            max_count = max(max_count, len(queue))
            # print queue
            pass
        return max_count

# ================================================================================
# ================================================================================
# ================================================================================
# ================================================================================
# ================================================================================


so = Solution()
print so.longestOnes([1,1,1,0,0,0,1,1,1,1,0], 2)

